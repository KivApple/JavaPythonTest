import java.nio.file.Paths
import org.apache.tools.ant.taskdefs.condition.Os

apply plugin: 'java'
apply plugin: 'c'
apply plugin: 'application'

sourceCompatibility = 1.8
targetCompatibility = 1.8

compileJava.options.encoding = 'UTF-8'

project.version = '0.0.1'

mainClassName = 'com.eternal_search.java_python_test.Main'

jar {
	baseName = project.name
	
	manifest {
		attributes 'Main-Class': mainClassName
	}
}

run {
	systemProperty 'java.library.path', "${project.buildDir}/libs/pythonProxy/shared"
}

model {
	components {
		pythonProxy(NativeLibrarySpec) {}
	}
}

ext.cLibs = []
ext.cLibsDirs = []
ext.cIncludeDirs = []
ext.cFlags = []

def jniPlatform = Os.isFamily(Os.FAMILY_WINDOWS) ? 'win32' : Os.isFamily(Os.FAMILY_UNIX) ? 'linux' : 'darwin'
def jniIncludeDir = Paths.get(System.getProperty('java.home'), '..', "include").normalize().toString().replace("\\","/")
cIncludeDirs.add(jniIncludeDir)
cIncludeDirs.add("$jniIncludeDir/$jniPlatform")

def pkgConfigQuery(String query) {
	def pkgConfig = "pkg-config $query".execute()
	pkgConfig.waitFor()
	return pkgConfig.in.text.trim()
}
def pythonFoundInPkgConfig = false
for (String flag : pkgConfigQuery('python3 --cflags --libs').split(' ')) {
	if (flag.startsWith('-I')) {
		cIncludeDirs.add(flag.substring(2))
		pythonFoundInPkgConfig = true
	} else if (flag.startsWith('-L')) {
		cLibsDirs.add(flag.substring(2))
	} else if (flag.startsWith('-l')) {
		cLibs.add(flag.substring(2))
	} else {
		cFlags.add(flag)
	}
}
if (!pythonFoundInPkgConfig) {
	def paths = System.getenv('PATH').split(Os.isFamily(Os.FAMILY_WINDOWS) ? ';' : ':')
	def libs = new HashSet<String>()
	for (String path : paths) {
		if(new File(path + File.separator + "python").exists() || new File(path + File.separator + "python.exe").exists()) {
			cIncludeDirs.add(path.toString() + File.separator + "include")
			def libsDir = path.toString() + File.separator + "libs"
			cLibsDirs.add(libsDir)
			for (File fileEntry : new File(libsDir).listFiles()) {
				int i1=fileEntry.toString().lastIndexOf("libs") + 5
				int i2=fileEntry.toString().lastIndexOf(".")
				libs.add(fileEntry.toString().substring(i1))
			}
		}
	}
	for (String lib : libs) {
		cLibs.add(lib)
	}
}

model {
	binaries {
		withType(SharedLibraryBinarySpec) {
			def includeDirFlagPrefix, libraryDirFlagPrefix, libraryFlagPrefix, libraryFlagSuffix
			if (toolChain in VisualCpp) {
				includeDirFlagPrefix = '/I'
				libraryDirFlagPrefix = '/LIBPATH:'
				libraryFlagPrefix = ''
				libraryFlagSuffix = '.lib'
			} else {
				includeDirFlagPrefix = '-I'
				libraryDirFlagPrefix = '-L'
				libraryFlagPrefix = '-l'
				libraryFlagSuffix = ''
			}
			for (String includeDir : cIncludeDirs) {
				cCompiler.args "$includeDirFlagPrefix$includeDir"
			}
			for (String libraryDir : cLibsDirs) {
				linker.args "$libraryDirFlagPrefix$libraryDir"
			}
			for (String library : cLibs) {
				linker.args "$libraryFlagPrefix$library$libraryFlagSuffix"
			}
		}
		withType(StaticLibraryBinarySpec) {
			def includeDirFlagPrefix, libraryDirFlagPrefix, libraryFlagPrefix, libraryFlagSuffix
			if (toolChain in VisualCpp) {
				includeDirFlagPrefix = '/I'
				libraryDirFlagPrefix = '/LIBPATH:'
				libraryFlagPrefix = ''
				libraryFlagSuffix = '.lib'
			} else {
				includeDirFlagPrefix = '-I'
				libraryDirFlagPrefix = '-L'
				libraryFlagPrefix = '-l'
				libraryFlagSuffix = ''
			}
			for (String includeDir : cIncludeDirs) {
				cCompiler.args "$includeDirFlagPrefix$includeDir"
			}
			for (String libraryDir : cLibsDirs) {
				linker.args "$libraryDirFlagPrefix$libraryDir"
			}
			for (String library : cLibs) {
				linker.args "$libraryFlagPrefix$library$libraryFlagSuffix"
			}
		}
	}
}
run.dependsOn 'pythonProxySharedLibrary'

task wrapper(type: Wrapper) {
    gradleVersion = '4.0.1'
}
